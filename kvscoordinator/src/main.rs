use clap::Parser;
use kvsinterface::KvsClient;
use std::{net::SocketAddr, time::Duration};
use tarpc::{client, context, tokio_serde::formats::Json};
use tokio::time::sleep;

#[derive(Parser)]
struct Flags {
    #[clap(long)]
    server_addr: SocketAddr,
    #[clap(long, default_value_t = 0)]
    first_transaction: u64,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let flags = Flags::parse();

    let mut transport = tarpc::serde_transport::tcp::connect(flags.server_addr, Json::default);
    transport.config_mut().max_frame_length(usize::MAX);

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let client = KvsClient::new(client::Config::default(), transport.await?).spawn();

    for i in 0..3 {
        let mut should_abort = false;

        match client.begin(context::current(), flags.first_transaction + i + 0).await {
            Ok(response) => println!("got the response: {:?}", response),
            Err(e) => println!("got the RPC error: {}", e),
        }

        match client.put(context::current(), flags.first_transaction + i + 0, "Hello".into(), 42).await {
            Ok(response) => {
                println!("got the response: {:?}", response);
                if let Err(_) = response {
                    should_abort = true;
                    println!("aborting");
                }
            },
            Err(e) => println!("got the RPC error: {}", e),
        }

        match client.put(context::current(), flags.first_transaction + i + 0, "World".into(), 43).await {
            Ok(response) => {
                println!("got the response: {:?}", response);
                if let Err(_) = response {
                    should_abort = true;
                    println!("aborting");
                }
            },
            Err(e) => println!("got the RPC error: {}", e),
        }

        let res = if should_abort {
            client.abort(context::current(), flags.first_transaction + i + 0).await
        } else {
            client.commit(context::current(), flags.first_transaction + i + 0).await
        };
        match res {
            Ok(response) => println!("got the response: {:?}", response),
            Err(e) => println!("got the RPC error: {}", e),
        }

        should_abort = false;

        match client.begin(context::current(), flags.first_transaction + i + 1).await {
            Ok(response) => println!("got the response: {:?}", response),
            Err(e) => println!("got the RPC error: {}", e),
        }

        match client.get(context::current(), flags.first_transaction + i + 1, "Hello".into()).await {
            Ok(response) => {
                println!("got the response: {:?}", response);
                if let Err(_) = response {
                    should_abort = true;
                    println!("aborting");
                }
            },
            Err(e) => println!("got the RPC error: {}", e),
        }

        match client.put(context::current(), flags.first_transaction + i + 1, "World".into(), 42).await {
            Ok(response) => {
                println!("got the response: {:?}", response);
                if let Err(_) = response {
                    should_abort = true;
                    println!("aborting");
                }
            },
            Err(e) => println!("got the RPC error: {}", e),
        }

        let res = if should_abort {
            client.abort(context::current(), flags.first_transaction + i + 1).await
        } else {
            client.commit(context::current(), flags.first_transaction + i + 1).await
        };
        match res {
            Ok(response) => println!("got the response: {:?}", response),
            Err(e) => println!("got the RPC error: {}", e),
        }
    }

    // idk I think the example client does this for a reason though
    // something about letting a span processor finish
    sleep(Duration::from_micros(1)).await;

    Ok(())
}
